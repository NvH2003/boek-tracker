-- Boek Tracker – Supabase schema voor sync
-- Voer dit uit in Supabase Dashboard → SQL Editor (eenmalig)

-- Profiel: koppelt Supabase user id aan gebruikersnaam (voor zoeken/weergave)
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  username text unique not null
);

alter table public.profiles enable row level security;

create policy "Profielen zijn leesbaar voor ingelogde gebruikers"
  on public.profiles for select to authenticated using (true);

create policy "Gebruiker kan eigen profiel aanmaken"
  on public.profiles for insert to authenticated with check (auth.uid() = id);

create policy "Gebruiker kan eigen profiel updaten"
  on public.profiles for update to authenticated using (auth.uid() = id);

create policy "Gebruiker kan eigen profiel verwijderen"
  on public.profiles for delete to authenticated using (auth.uid() = id);

-- User data: boeken, planken, challenge, vrienden (één rij per user per key)
create table if not exists public.user_data (
  user_id uuid not null references auth.users(id) on delete cascade,
  key text not null,
  value jsonb not null default '{}',
  primary key (user_id, key)
);

alter table public.user_data enable row level security;

create policy "Gebruiker leest alleen eigen data"
  on public.user_data for select to authenticated using (auth.uid() = user_id);

-- Vrienden mogen elkaars data lezen (voor Boekbuddy-leeslijst op ander apparaat)
create policy "Gebruiker leest data van vrienden"
  on public.user_data for select to authenticated
  using (
    (select ud.value from public.user_data ud where ud.user_id = auth.uid() and ud.key = 'friends')
    @> jsonb_build_array((select p.username from public.profiles p where p.id = user_data.user_id))
  );

create policy "Gebruiker schrijft alleen eigen data"
  on public.user_data for all to authenticated using (auth.uid() = user_id);

-- Vriendschapsverzoeken (we gebruiken username, opgeslagen in from_username / to_username)
create table if not exists public.friend_requests (
  id bigint generated by default as identity primary key,
  from_username text not null,
  to_username text not null,
  status text not null check (status in ('pending', 'accepted', 'rejected')),
  created_at timestamptz default now(),
  unique (from_username, to_username)
);

alter table public.friend_requests enable row level security;

-- Iedereen mag verzoeken lezen (nodig om inkomende/uitgaande te tonen)
create policy "Verzoeken leesbaar voor ingelogde gebruikers"
  on public.friend_requests for select to authenticated using (true);

create policy "Verzoeken insert voor ingelogde gebruikers"
  on public.friend_requests for insert to authenticated with check (true);

create policy "Verzoeken update voor ingelogde gebruikers"
  on public.friend_requests for update to authenticated using (true);

create policy "Verzoeken delete voor ingelogde gebruikers"
  on public.friend_requests for delete to authenticated using (true);

-- Shared inbox: per user een rij met items (jsonb array)
create table if not exists public.shared_inbox (
  user_id uuid primary key references auth.users(id) on delete cascade,
  items jsonb not null default '[]'
);

alter table public.shared_inbox enable row level security;

create policy "Gebruiker leest eigen inbox"
  on public.shared_inbox for select to authenticated using (auth.uid() = user_id);

create policy "Gebruiker schrijft eigen inbox"
  on public.shared_inbox for all to authenticated using (auth.uid() = user_id);

-- Trigger: na signup via Supabase Auth een profiel aanmaken (username uit email prefix)
-- We doen dit in de app: na signUp voegen we handmatig de profile row toe.
